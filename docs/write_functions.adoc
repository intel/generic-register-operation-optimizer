
=== Write Functions

Each field and register is parameterized with a _write function_. By default,
the write function is `groov::w::replace`.

[source,cpp]
----
using my_field = groov::field<"field", std::uint32_t, 3, 0, groov::w::replace>;
----

==== Write functions

Built-in write functions are in the `groov::w` namespace. Examples are:

- `replace` ("normal write")
- `ignore` ("read-only" in loose parlance - but see note later)

There are 16 possible write functions, each characterized by a truth table
relating the current value *C*, the written value *W* and the result *R*. For
example:

.Truth table for replace
[width=30%,cols="1,1,1"]
|===
^h|C ^h|W ^h|R

^|0 ^|0 ^|0
^|0 ^|1 ^|1
^|1 ^|0 ^|0
^|1 ^|1 ^|1
|===

.Truth table for ignore
[width=30%,cols="1,1,1"]
|===
^h|C ^h|W ^h|R

^|0 ^|0 ^|0
^|0 ^|1 ^|0
^|1 ^|0 ^|1
^|1 ^|1 ^|1
|===

The purpose of the write function is to control behaviour when writing, for example:

* a bus can avoid a read-modify-write by writing identity bits to a field that is not being written to by the user
* a user can generically set or clear a field

==== Identity, Set and Clear specs

Each write function may have types (_mask specs_) exposed:

* `id_spec`: an identity mask spec
* `set_spec`: a set mask spec
* `clear_spec`: a clear mask spec

A valid write function _must_ have at least one of these types exposed, and _may_ have all of them.

There are three possible mask specs, in the namespace `groov::m`:

- `zero` (mask of zeroes)
- `one` (mask of ones)
- `any` (mask of X)

Each mask spec has a function that computes the mask for a field according to
its bit range:

[source,cpp]
----
template <std::unsigned_integral T, std::size_t Msb, std::size_t Lsb>
constexpr static auto mask() -> T;
----

==== Building the write masks

In the general case, a given write to a register will only want to write some of
the field values. The other field values are left unspecified. The write
machinery uses the field write functions and their associated identity specs to
compute:

- the write mask for the fields to be written
- the identity mask for the other fields
- the identity value (if any) for the other fields

For example:

[source,cpp]
----
// the default write function is groov::w::replace
using my_field_0 = groov::field<"field_0", std::uint32_t, 9, 0>;
using my_field_1 = groov::field<"field_1", std::uint32_t, 31, 10>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field_0, my_field_1>;

// when writing only field_1:
write(grp("my_reg.field_1"_f = 42));

// results in a call to bus::write as if:
constexpr auto write_mask = 0xffff'fc00u; // mask for field_1
constexpr auto identity_mask = 0u;        // field_0 has id_spec none
constexpr auto identity_value = 0u;       // field_0 has id_spec none

// the write mask and the identity mask don't cover the range of the register,
// so the bus must read-modify-write to preserve unwritten bits
bus::template write<write_mask, identity_mask, identity_value>(/* ... */);
----

But if the unwritten field(s) are "read-only", i.e. have the `ignore` write
function (or otherwise have an identity):

[source,cpp]
----
using my_field_0 = groov::field<"field_0", std::uint32_t, 9, 0, groov::w::ignore>;
using my_field_1 = groov::field<"field_1", std::uint32_t, 31, 10>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field_0, my_field_1>;

// when writing only field_1:
write(grp("my_reg.field_1"_f = 42));

// results in a call to bus::write as if:
constexpr auto write_mask = 0xffff'fc00u;    // mask for field_1
constexpr auto identity_mask = 0x0000'03ffu; // field_0 has id_spec any
constexpr auto identity_value = 0u;          // field_0 has id_spec any (zeroes are arbitrary)

// the write mask and the identity mask cover the range of the register,
// so the bus may OR the identity value with the written value to preserve
// unwritten bits and avoid read-modify-write
bus::template write<write_mask, identity_mask, identity_value>(/* ... */);
----

==== Custom write functions

Custom write functions can be used to deal with registers that have special requirements.

NOTE: Try not to think of registers/fields as simply "read-only" or similar. While
"read-only" is a good interface-level abstraction, it's not the same concept when
dealing with hardware. Individual bits are not addressable, so a register whose
bits are not _all_ "read-only" must be written with _some value_ for those bits
(which the hardware may or may not ignore). This is the job of the write
function in concert with the bus.

Imagine that we have a register containing one "writable" bit, and other reserved
bits whose write semantics are specified:

[width=80%,cols="4,1,8"]
|===
^h|Field ^h|Bits ^h|Description

^|Reserved ^|7 ^|Reserved. Write as 0.
^|Reserved ^|6 ^|Reserved. Write as 1.
^|Reserved ^|5 ^|Reserved. Write as 1.
^|Reserved ^|4 ^|Reserved. Write as 0.
^|Reserved ^|3 ^|Reserved. Write as 0.
^|Reserved ^|2 ^|Reserved. Write as 0.
^|ENABLE   ^|1 ^|Enable bit.
^|Reserved ^|0 ^|Reserved. Write as 0.
|===

Note the write semantics here. Bits 5 and 6 must be written as `1`. The other
reserved bits must be written as `0`.

In order to model this, we could create 3 fields inside a single register -- with
an appropriate group and bus:
[source,cpp]
----
using F0 = groov::field<"reserved0", std::uint8_t, 0, 0, groov::w::ignore>;
using FE = groov::field<"enable", std::uint8_t, 1, 1>;
using F1 = groov::field<"reserved1", std::uint8_t, 7, 2, custom_write_func>;

using R =
    groov::reg<"reg", std::uint32_t, REG_ADDRESS, groov::w::replace, F0, FE, F1>;
using G = groov::group<"group1", bus_t, R>;
----

Notice that `R`â€‹'s write function is the default `w::replace` which is
overridden at the level of individual fields. We are going to write to this
register, after all.

In user code, we'll only write to the `enable` field (`FE`):
[source,cpp]
----
groov::write(G{}("reg.enable"_f = 1)) | async::sync_wait();
----

The table tells us to write bit 0 as 0, and this is already the default given by
`w::ignore`, so that's OK for `F0`.

The `custom_write_func` needs to provide the correct "identity value" to
write to `F1`. This it can do with an appropriate `id_spec`:
[source,cpp]
----
struct custom_write_func {
    struct id_spec {
        template <std::unsigned_integral T, std::size_t Msb, std::size_t Lsb>
        constexpr static auto mask() -> T {
            // sanity checks: this is just for F1
            static_assert(Msb == 7);
            static_assert(Lsb == 2);
            return 0b0110'0000u; // bits 5 and 6 are 1
        }
    };
};
----

And the bus's `write` function must take account of the identity mask and value
as well as the user-supplied bit(s) to write, for example:
[source,cpp]
----
template <auto Mask, auto IdMask, auto IdValue>
static auto write(auto addr, auto value) -> async::sender auto {
    return async::just_result_of([=] {
        auto prev = *addr & ~(Mask | IdMask);
        *addr = prev | value | IdValue;
    });
}
----

The result of this is that when we write to the `enable` field, the other bits
of the register get written correctly.

NOTE: If a register has bits that are not addressed by any fields, the identity
values for those fields will be taken from the write function on the register
itself.

=== Read-only fields

A field may be denoted read-only by marking its write function as such:

[source,cpp]
----
using FR = groov::field<"reserved", std::uint8_t, 1, 1, groov::read_only<groov::w::ignore>>;
----

If a field is marked read-only, it's a compile-time error to attempt to assign it a value:

[source,cpp]
----
groov::write(G{}("reg.reserved"_f = 1)) | async::sync_wait();
// compile error: "Attempting to write to a read-only field: reserved"
----

A write function wrapped with `read_only` in this way _must_ have an `id_spec` that
provides its identity bits. When the register containing a read-only field is
written, the bits provided by the `id_spec` for the read-only field(s) will be
used.

NOTE: This illustrates the difference between `ignore` (which is how the
hardware treats writes) and `read_only` (which is an API-level decision).
`ignore` is not `read_only` because there is no hardware prohibition on writing.
The prohibition on writing is enforced at the API level.

=== Generic writing: `set` and `clear`

Fields with an appropriate `set_spec` and/or `clear_spec` in their
`write_function` can be generically written to by asking for `set` or `clear`:

[source,cpp]
----
// the (default) groov::w::replace write function has:
// using set_spec = groov::m::one;
// using clear_spec = groov::m::zero;

using my_field = groov::field<"field", std::uint32_t, 1, 0>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::set));   // write all ones
write(grp("my_reg.field"_f = groov::clear)); // write all zeroes
----

Another example: a field's write function may be `one_to_clear`.

[source,cpp]
----
// the groov::w::one_to_clear write function has:
// (no set_spec defined)
// using clear_spec = groov::m::one;

using my_field = groov::field<"field", std::uint32_t, 1, 0, groov::w::one_to_clear>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::set));   // error! no set_spec is defined
write(grp("my_reg.field"_f = groov::clear)); // writes all ones
----

=== Generic writing: `enable` and `disable`

Sometimes it is useful for a field's type to be an enumeration, and that field
may have the concept of `enable` and `disable`. In this case, the field can be
written by asking for `enable` or `disable`.

[source,cpp]
----
enum struct E { ENABLE = 0, DISABLE = 1, OTHER = 2 };
using my_field = groov::field<"field", E, 1, 0>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::enable));  // writes ENABLE (0)
write(grp("my_reg.field"_f = groov::disable)); // writes DISABLE (1)
----

The enumeration may be more than one bit. It must have `ENABLE` and `DISABLE`
values for `enable` and `disable` to work respectively.
