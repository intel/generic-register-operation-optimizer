
=== Write Functions

Each field and register is parameterized with a _write function_. By default,
the write function is `groov::w::replace`.

[source,cpp]
----
using my_field = groov::field<"field", std::uint32_t, 3, 0, groov::w::replace>;
----

==== Write functions

Built-in write functions are in the `groov::w` namespace. Examples are:

- `replace` ("normal write")
- `ignore` ("read-only" in loose parlance - but see note later)

There are 16 possible write functions, each characterized by a truth table
relating the current value *C*, the written value *W* and the result *R*. For
example:

.Truth table for replace
[width=30%,cols="1,1,1"]
|===
^h|C ^h|W ^h|R

^|0 ^|0 ^|0
^|0 ^|1 ^|1
^|1 ^|0 ^|0
^|1 ^|1 ^|1
|===

.Truth table for ignore
[width=30%,cols="1,1,1"]
|===
^h|C ^h|W ^h|R

^|0 ^|0 ^|0
^|0 ^|1 ^|0
^|1 ^|0 ^|1
^|1 ^|1 ^|1
|===

The purpose of the write function is to control behaviour when writing, for example:

* a bus can avoid a read-modify-write by writing identity bits to a field that is not being written to by the user
* a user can generically set or clear a field

==== Identity, Set and Clear specs

Each write function may have types (_mask specs_) exposed:

* `id_spec`: an identity mask spec
* `set_spec`: a set mask spec
* `clear_spec`: a clear mask spec

A valid write function _must_ have at least one of these types exposed, and _may_ have all of them.

There are three possible mask specs, in the namespace `groov::m`:

- `zero` (mask of zeroes)
- `one` (mask of ones)
- `any` (mask of X)

Each mask spec has a function that computes the mask for a field according to
its bit range:

[source,cpp]
----
template <std::unsigned_integral T, std::size_t Msb, std::size_t Lsb>
constexpr static auto mask() -> T;
----

==== Building the write masks

In the general case, a given write to a register will only want to write some of
the field values. The other field values are left unspecified. The write
machinery uses the field write functions and their associated identity specs to
compute:

- the write mask for the fields to be written
- the identity mask for the other fields
- the identity value (if any) for the other fields

For example:

[source,cpp]
----
// the default write function is groov::w::replace
using my_field_0 = groov::field<"field_0", std::uint32_t, 9, 0>;
using my_field_1 = groov::field<"field_1", std::uint32_t, 31, 10>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field_0, my_field_1>;

// when writing only field_1:
write(grp("my_reg.field_1"_f = 42));

// results in a call to bus::write as if:
constexpr auto write_mask = 0xffff'fc00u; // mask for field_1
constexpr auto identity_mask = 0u;        // field_0 has id_spec none
constexpr auto identity_value = 0u;       // field_0 has id_spec none

// the write mask and the identity mask don't cover the range of the register,
// so the bus must read-modify-write to preserve unwritten bits
bus::template write<"my_reg", write_mask, identity_mask, identity_value>(/* ... */);
----

But if the unwritten field(s) are "read-only", i.e. have the `ignore` write
function (or otherwise have an identity):

[source,cpp]
----
using my_field_0 = groov::field<"field_0", std::uint32_t, 9, 0, groov::w::ignore>;
using my_field_1 = groov::field<"field_1", std::uint32_t, 31, 10>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field_0, my_field_1>;

// when writing only field_1:
write(grp("my_reg.field_1"_f = 42));

// results in a call to bus::write as if:
constexpr auto write_mask = 0xffff'fc00u;    // mask for field_1
constexpr auto identity_mask = 0x0000'03ffu; // field_0 has id_spec any
constexpr auto identity_value = 0u;          // field_0 has id_spec any (zeroes are arbitrary)

// the write mask and the identity mask cover the range of the register,
// so the bus may OR the identity value with the written value to preserve
// unwritten bits and avoid read-modify-write
bus::template write<"my_reg", write_mask, identity_mask, identity_value>(/* ... */);
----

==== Custom write functions

Custom write functions can be used to deal with registers that have special requirements.

NOTE: Try not to think of registers/fields as simply "read-only" or similar. While
"read-only" is a good interface-level abstraction, it's not the same concept when
dealing with hardware. Individual bits are not addressable, so a register whose
bits are not _all_ "read-only" must be written with _some value_ for those bits
(which the hardware may or may not ignore). This is the job of the write
function in concert with the bus.

Imagine that we have a register containing one "writable" bit, and other reserved
bits whose write semantics are specified:

[width=80%,cols="4,1,8"]
|===
^h|Field ^h|Bits ^h|Description

^|Reserved ^|7 ^|Reserved. Write as 0.
^|Reserved ^|6 ^|Reserved. Write as 1.
^|Reserved ^|5 ^|Reserved. Write as 1.
^|Reserved ^|4 ^|Reserved. Write as 0.
^|Reserved ^|3 ^|Reserved. Write as 0.
^|Reserved ^|2 ^|Reserved. Write as 0.
^|ENABLE   ^|1 ^|Enable bit.
^|Reserved ^|0 ^|Reserved. Write as 0.
|===

Note the write semantics here. Bits 5 and 6 must be written as `1`. The other
reserved bits must be written as `0`.

In order to model this, we could create 3 fields inside a single register -- with
an appropriate group and bus:
[source,cpp]
----
using F0 = groov::field<"reserved0", std::uint8_t, 0, 0, groov::w::ignore>;
using FE = groov::field<"enable", std::uint8_t, 1, 1>;
using F1 = groov::field<"reserved1", std::uint8_t, 7, 2, custom_write_func>;

using R =
    groov::reg<"reg", std::uint32_t, REG_ADDRESS, groov::w::replace, F0, FE, F1>;
using G = groov::group<"group1", bus_t, R>;
----

Notice that `R`â€‹'s write function is the default `w::replace` which is
overridden at the level of individual fields. We are going to write to this
register, after all.

In user code, we'll only write to the `enable` field (`FE`):
[source,cpp]
----
groov::write(G{}("reg.enable"_f = 1)) | async::sync_wait();
----

The table tells us to write bit 0 as 0, and this is already the default given by
`w::ignore`, so that's OK for `F0`.

The `custom_write_func` needs to provide the correct "identity value" to
write to `F1`. This it can do with an appropriate `id_spec`:
[source,cpp]
----
struct custom_write_func {
    struct id_spec {
        template <std::unsigned_integral T, std::size_t Msb, std::size_t Lsb>
        constexpr static auto mask() -> T {
            // sanity checks: this is just for F1
            static_assert(Msb == 7);
            static_assert(Lsb == 2);
            return 0b0110'0000u; // bits 5 and 6 are 1
        }
    };
};
----

And the bus's `write` function must take account of the identity mask and value
as well as the user-supplied bit(s) to write, for example:
[source,cpp]
----
template <auto Mask, auto IdMask, auto IdValue>
static auto write(auto addr, auto value) -> async::sender auto {
    return async::just_result_of([=] {
        auto prev = *addr & ~(Mask | IdMask);
        *addr = prev | value | IdValue;
    });
}
----

The result of this is that when we write to the `enable` field, the other bits
of the register get written correctly.

NOTE: If a register has bits that are not addressed by any fields, the identity
values for those fields will be taken from the write function on the register
itself.

=== Read- and write-only semantics

Fields and registers may be marked read-only and write-only. A field's semantics
take precedence over a register's semantics: that is, the register's semantics
will apply only to bits in the register that are not covered by fields (should
any such bits exist).

==== Read-only fields

A field may be denoted read-only by marking its write function as such:

[source,cpp]
----
using FR = groov::field<"reserved", std::uint8_t, 1, 1, groov::read_only<groov::w::ignore>>;
----

If a field is marked read-only, it's a compile-time error to attempt to assign it a value:

[source,cpp]
----
groov::write(G{}("reg.reserved"_f = 1)) | async::sync_wait();
// compile error: "Attempting to write to a read-only field: reserved"
----

A write function wrapped with `read_only` in this way _must_ have an `id_spec` that
provides its identity bits.

NOTE: This illustrates the difference between `ignore` (which is how the
hardware treats writes) and `read_only` (which is an API-level decision).
`ignore` is not `read_only` because there is no hardware prohibition on writing.
The prohibition on writing is enforced at the API level.

==== Write-only fields

Write-only registers and fields also exist. In hardware terms, the usual case
here is that data is not stored, but writes cause edge-trigger effects.

A field may be denoted write-only by marking its write function as such:

[source,cpp]
----
using FW = groov::field<"f", std::uint8_t, 1, 1, groov::write_only<groov::w::replace>>;
----

If a field is marked `write_only`, it's a compile-time error to attempt to read
from it:

[source,cpp]
----
groov::read(G{}("reg.f"_f)) | async::sync_wait();
// compile error: "Attempting to read from a write-only field: f"
----

A write function wrapped with `write_only` may or may not have an `id_spec` that
provides its "safe-to-write" identity bits. This depends on hardware semantics:
a field might be edge-triggered by writing 1, with 0 doing nothing, or the
reverse, or it might not have an identity value.

Because writing happens to a register, not an individual field, it may also be
an error to write without "covering" all the bits marked as write-only --
because this would incur a read-modify-write (RMW).

NOTE: Which bits are required are affected by how a bus optionally implements
`transform_mask`.

The bits in question might be in other fields:

[source,cpp]
----
using F0 = groov::field<"f0", std::uint8_t, 0, 0, groov::write_only<groov::w::replace>>;
using F1 = groov::field<"f1", std::uint8_t, 1, 1, groov::write_only<groov::w::replace>>;

using R = groov::reg<"reg", std::uint32_t, addr, groov::w::ignore, F0, F1>;

groov::write(G{}("reg.f0"_f = 1)) | async::sync_wait();
// compile error: "Write would incur RMW on a write-only field: f1"
----

Or they might be unused by fields, but marked by the register itself:

[source,cpp]
----
using F = groov::field<"f0", std::uint8_t, 0, 0, groov::write_only<groov::w::replace>>;
using R = groov::reg<"reg", std::uint32_t, addr, groov::write_only<groov::w::replace>, F>;

groov::write(G{}("reg.f"_f = 1)) | async::sync_wait();
// compile error: "Write to register reg would incur RMW on write-only bits"
----

This second case is probably an error in definition: a write-only register
should probably either be fully covered by fields, or contain no fields. The
normal useful case for a sparse "write-only" register is that it has an `ignore`
write function. This avoids read-modify-write and means any unused bits just
get written as zero.

NOTE: `read_only` and `write_only` are not symmetric concepts! It is permitted
to write -- but only indirectly by writing other fields in the same register --
to `read_only` fields, using their identity values: such a write is safe and
would have no effect. However, it is *not* permitted to read from a `write_only`
field either directly or indirectly, because there is no stored data there to
read.

=== Generic writing: `set` and `clear`

Fields with an appropriate `set_spec` and/or `clear_spec` in their
`write_function` can be generically written to by asking for `set` or `clear`:

[source,cpp]
----
// the (default) groov::w::replace write function has:
// using set_spec = groov::m::one;
// using clear_spec = groov::m::zero;

using my_field = groov::field<"field", std::uint32_t, 1, 0>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::set));   // write all ones
write(grp("my_reg.field"_f = groov::clear)); // write all zeroes
----

Another example: a field's write function may be `one_to_clear`.

[source,cpp]
----
// the groov::w::one_to_clear write function has:
// (no set_spec defined)
// using clear_spec = groov::m::one;

using my_field = groov::field<"field", std::uint32_t, 1, 0, groov::w::one_to_clear>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::set));   // error! no set_spec is defined
write(grp("my_reg.field"_f = groov::clear)); // writes all ones
----

=== Generic writing: `enable` and `disable`

Sometimes it is useful for a field's type to be an enumeration, and that field
may have the concept of `enable` and `disable`. In this case, the field can be
written by asking for `enable` or `disable`.

[source,cpp]
----
enum struct E { ENABLE = 0, DISABLE = 1, OTHER = 2 };
using my_field = groov::field<"field", E, 1, 0>;
using my_reg = groov::reg<"reg", std::uint32_t, 0xa'0000, groov::w::replace,
                           my_field>;

write(grp("my_reg.field"_f = groov::enable));  // writes ENABLE (0)
write(grp("my_reg.field"_f = groov::disable)); // writes DISABLE (1)
----

The enumeration may be more than one bit. It must have `ENABLE` and `DISABLE`
values for `enable` and `disable` to work respectively.
